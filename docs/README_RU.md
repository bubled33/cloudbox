# Cloud File Storage (Google Drive Lite)

> Язык / Language: RU | [EN](./README_RU.md)

---

### Введение

Cloud File Storage — это веб‑сервис на Go для хранения файлов, управления версиями и временного шаринга через публичные ссылки с коротким TTL, с использованием фоновых воркеров для генерации превью и метрик.  
Проект реализован с использованием слоистой и гексагональной архитектуры с явным разделением на доменный, прикладной, инфраструктурный слои, слой API и воркеров, чтобы изолировать бизнес‑логику от фреймворков и внешних систем.  

**Основные возможности:**  
- Безпарольная аутентификация по email‑магик‑линкам и сессионным токенам.  
- Версионирование файлов с возможностью восстановления, обновления метаданных и ограничениями по размеру и объёму.  
- Временные публичные ссылки с жёстким TTL и автоматическим отключением воркером.  
- Асинхронная генерация превью файлов через очередь и отдельный воркер.  
- Встроенный эндпоинт метрик и трассировка на базе OpenTelemetry.  
- Документация API в формате OpenAPI/Swagger, доступная прямо из запущенного сервиса.  

---

### Нефункциональные требования

Система разрабатывается как MVP, но ориентируется на продакшен‑подобные требования к доступности, производительности и надёжности.  

| Метрика                      | Обозначение          | Требование                    |
|-----------------------------|----------------------|-------------------------------|
| Доступность сервиса         | \(Uptime\)           | \(Uptime \geq 99.5\%\)        |
| Время восстановления        | \(RTO\)              | \(RTO \leq 1 \text{ h}\)      |
| Потеря данных при аварии    | \(RPO\)              | \(RPO \leq 1 \text{ h}\)      |
| Задержка API (p95)          | \(Latency_{p95}\)    | \(\leq 200 \text{ ms}\)       |
| Пропускная способность (upload)   | \(RPS_{upload}\)   | \(\leq 100\)                  |
| Пропускная способность (download) | \(RPS_{download}\) | \(\leq 300\)                  |
| Одновременные пользователи  | \(N_{active}\)       | \(\geq 1000\)                 |
| Максимальный размер файла   | \(Size_{file}\)      | \(\leq 10 \text{ GB}\)        |
| Общая ёмкость (MVP)         | \(Size_{total}\)     | \(\geq 1 \text{ TB}\)         |
| Время генерации превью      | \(T_{preview}\)      | \(\leq 30 \text{ s}\)         |
| Вместимость очереди         | \(N_{queue}\)        | \(\leq 10^{4}\)               |
| Доля успешных задач         | \(P_{success}\)      | \(\geq 99\%\)                 |
| TTL публичной ссылки        | \(TTL_{link}\)       | \(\leq 600 \text{ s}\)        |

Эти ограничения определяют решения по архитектуре: использование асинхронных задач, разделение API и воркеров, базовую наблюдаемость и метрики.  

---

### Технологический стек

Проект использует современную экосистему Go и стандартный набор инструментов для REST API, хранения данных, очередей и документации.  

| Слой / Назначение                 | Технология / Библиотека                           | Использование |
|-----------------------------------|---------------------------------------------------|--------------|
| Язык программирования             | Go (Golang)                                       | Основной язык backend‑части (API и воркеры). |
| HTTP‑фреймворк / роутер          | Gin                                               | Лёгкий и быстрый HTTP‑роутер для REST API. |
| Документация API                 | Swag + gin‑swagger                                | Генерация и отдача Swagger UI по пути `/swagger`. |
| База данных                      | PostgreSQL                                        | Хранение пользователей, сессий, файлов, версий, ссылок, событий. |
| Миграции БД                      | SQL‑миграции в каталоге `migrations/`             | Версионируемая схема, накатываемая на старте или отдельным инструментом. |
| Доступ к данным                  | Кастомные репозитории поверх `database/sql`       | Query/Command‑репозитории в `internal/infra/db`. |
| Объектное хранилище             | S3 / MinIO                                        | Хранение бинарных данных файлов и превью. |
| Очередь / брокер сообщений      | Kafka‑подобные интерфейсы + in‑memory mock        | Очереди превью и событий с мок‑реализацией для локальной разработки. |
| Аутентификация / магик‑линки    | Кастомный сервис + SMTP‑рассылка                  | Безпарольный логин по подписанным ссылкам и сессиям. |
| Фоновые воркеры                 | Go‑бинарники `cmd/preview-worker`, `cmd/link-expirer` | Обработка превью, истечения ссылок, метрик, публикации событий. |
| Конфигурация                    | YAML (`configs/`) + `.env`                        | Базовая и окруженческая конфигурация с возможностью переопределения. |
| Логирование                     | Стандартный логгер (можно заменить на Zap/Logrus) | Централизованное логирование API и воркеров. |
| Метрики                         | HTTP‑эндпоинт `/api/v1/metrics`                   | Метрики в формате, удобном для Prometheus. |
| Трассировка                     | OpenTelemetry (stdout exporter)                   | Распределённая трассировка через middleware и TracerProvider. |
| Тестирование                    | `go test`, интеграционные тесты в `internal/test` | Unit‑, интеграционные и инфраструктурные тесты (DB, S3, очередь, API). |
| Контейнеризация (опционально)   | Docker / Docker Compose                           | Оркестрация Postgres, MinIO и очереди в дев‑окружении. |

Такой стек делает рантайм лёгким и при этом позволяет в будущем подключить реальный Kafka‑кластер, внешний SMTP и более продвинутый стек логирования/наблюдаемости.  

---

### Структура проекта

Репозиторий следует классической схеме Go: `cmd` для исполняемых бинарников и `internal` для приватной прикладной логики, с явным отражением гексагональной архитектуры и подхода DDD.  

```
cmd/
  api/             # Точка входа HTTP API сервера
  preview-worker/  # Воркер генерации превью
  link-expirer/    # Воркер истечения публичных ссылок
  docs/            # Точка входа для генерации/отдачи Swagger-доков

internal/
  api/             # HTTP-хендлеры, роутинг, middleware
  app/             # Прикладные сервисы, unit-of-work
  domain/          # Сущности, value-объекты, доменные события, интерфейсы
  infra/           # Адаптеры БД, очереди, SMTP, S3/MinIO
  workers/         # Логика воркеров (превью, метрики, проверки, публикация событий)
  config/          # Загрузка конфигурации
  test/            # Интеграционные тесты (DB, S3, очередь, API)
```

- `internal/domain` содержит ключевые сущности (user, file, file version, magic link, session, public link), value‑object‑ы и доменные события.  
- `internal/app` реализует use‑case‑ы через сервисы, unit‑of‑work и сценарии без зависимостей от фреймворков.  
- `internal/infra` предоставляет адаптеры для Postgres, S3/MinIO, очередей, SMTP и логирования.  
- `internal/api` включает Gin‑хендлеры, DTO, презентеры, а также middleware для аутентификации, обработки ошибок и трассировки.  
- `internal/workers` реализует логику генерации превью, агрегации метрик, проверки целостности файлов и публикации событий.  

Такое разделение удерживает фреймворки и драйверы на «краях» системы и защищает доменную логику от прямой зависимости от HTTP, SQL или деталей хранилища.  

---

### Исполняемые компоненты

Система собирается в несколько отдельных бинарников из пакетов `cmd/*`.  

- **API‑сервер (`cmd/api`)** — поднимает REST API, отдаёт Swagger UI, обрабатывает аутентификацию, операции с файлами и управление публичными ссылками.  
- **Preview Worker (`cmd/preview-worker`)** — читает задачи из очереди превью, генерирует миниатюры и пишет их в S3/MinIO.  
- **Link Expirer (`cmd/link-expirer`)** — деактивирует истёкшие публичные ссылки на основе TTL и доменных событий.  
- **Metrics Worker** — потребляет события и обновляет метрики, отдаваемые по `/api/v1/metrics`.  
- **File Checker Worker** — периодически проверяет консистентность файлов в хранилище и может инициировать очистку/починку.  
- **Event Publisher Worker** — читает непроброшенные доменные события и публикует их в очередь или внешние системы.  

Все компоненты используют общие доменный и прикладной слои, что гарантирует единые правила бизнес‑логики для API и воркеров.  

---

### Архитектура

Архитектура сочетает слоистый и гексагональный подходы, а также доменные события и очереди для декомпозиции операций и переноса тяжёлых задач в фон.  

**Слои:**  
- **Domain layer** — сущности, агрегаты, value‑объекты и интерфейсы для хранилищ, очередей, уведомлений и времени.  
- **Application layer** — сервисы, реализующие сценарии (auth, user, file, file version, magic link, session, public link, events), плюс unit‑of‑work.  
- **Infrastructure layer** — адаптеры к Postgres, очередям Kafka‑типа, S3/MinIO, SMTP, логированию и метрикам.  
- **Interface layer** — HTTP‑хендлеры, DTO, презентеры, middleware и точки входа воркеров.  

**Гексагональная архитектура (Ports & Adapters):**  
- Доменный код зависит только от небольших интерфейсов (портов) хранилища, очередей, уведомлений и времени.  
- Прикладной слой координирует доменные операции и использует unit‑of‑work для согласованной записи в БД.  
- Инфраструктурные адаптеры реализуют порты для Postgres, MinIO/S3, Kafka‑подобной очереди и SMTP, не протаскивая их API в домен.  

Благодаря этому можно относительно просто заменить in‑memory‑очередь на реальный Kafka или мок‑сторадж на S3/MinIO без изменений бизнес‑логики.  

---

### Пользовательские сценарии

Основные сценарии остаются прежними: загрузка файла, управление версиями и шаринг через краткоживущие публичные ссылки. Детальные диаграммы находятся в `./docs/userflow.svg`.  

Типовой сценарий:  
1. Пользователь запрашивает магик‑линк по email и получает подписанный URL.  
2. Пользователь переходит по ссылке, токен валидируется, создаётся сессия, привязанная к устройству и IP.  
3. Аутентифицированный пользователь загружает файл, создаётся начальная `FileVersion`, а бинарные данные кладутся в S3/MinIO.  
4. В очередь добавляется задача на генерацию превью, воркер создаёт миниатюру и сохраняет её в объектное хранилище.  
5. Пользователь создаёт публичную ссылку с коротким TTL и шарит её; воркер истечения ссылок деактивирует её после окончания срока.  

ER‑диаграмма в `./docs/models.svg` описывает таблицы и связи между пользователями, сессиями, магик‑линками, файлами, версиями, событиями и публичными ссылками.  

---

### Безопасность и аутентификация

Аутентификация реализована полностью без паролей и основана на email‑магик‑линках и управлении сессиями с возможностью их отзыва и контроля устройств.  

**Магик‑линки:**  
- Пользователь отправляет email для запроса ссылки входа; система генерирует подписанный токен с временем жизни.  
- Токен и метаданные (пользователь, IP, устройство, `expires_at`) сохраняются в БД и отправляются по email через SMTP.  
- При переходе по ссылке токен валидируется, и создаётся долговременная сессия.  

**Сессии:**  
- Сессии хранятся в БД с привязкой к пользователю, устройству, IP‑адресу и временем истечения.  
- API предоставляет эндпоинты для списка активных сессий, отзыва одной сессии, отзыва всех сессий и выхода из текущей.  
- Эндпоинт обновления токена позволяет ротировать access‑токены, удерживая контроль над долгоживущими сессиями.  

**Авторизация и доступ к данным:**  
- Аутентифицированный пользователь может работать только со своими файлами и версиями, что проверяется как на уровне БД, так и в доменной логике.  
- Доступ по публичной ссылке не требует аутентификации, но строго read‑only, ограничен по времени и привязан к конкретному файлу/версии.  
- Удаление файла каскадно удаляет версии, превью, публичные ссылки и связанные события согласно схеме БД.  

На продакшене предполагается использование HTTPS c терминацией на уровне прокси/ingress перед сервисом.  

---

### Обзор API

API версионируется под префиксом `/api/v1` и документируется через Swagger; Swagger UI доступен по адресу `/swagger/index.html`.  

**Публичные эндпоинты:**  

| Endpoint                         | Method | Описание |
|----------------------------------|--------|----------|
| `/swagger/*any`                  | GET    | Swagger UI и OpenAPI‑спецификация. |
| `/api/v1/metrics`               | GET    | Метрики сервиса. |
| `/api/v1/magic-links`           | POST   | Запрос магик‑линка для безпарольного входа по email. |
| `/api/v1/magic-links/{token}`   | GET    | Валидация магик‑линка и создание сессии. |
| `/api/v1/auth/tokens/refresh`   | POST   | Обновление access‑токена по действующей сессии. |
| `/api/v1/public-links/{token}`  | GET    | Загрузка файла по публичному токену. |

**Эндпоинты, требующие аутентификации (Authorization‑заголовок):**  

| Группа / Endpoint                            | Method | Описание |
|----------------------------------------------|--------|----------|
| `/api/v1/auth/sessions`                      | GET    | Список активных сессий текущего пользователя. |
| `/api/v1/auth/sessions/{session_id}`         | DELETE | Отзыв конкретной сессии. |
| `/api/v1/auth/sessions`                      | DELETE | Отзыв всех сессий пользователя. |
| `/api/v1/auth/sessions/current`              | DELETE | Выход из текущей сессии. |
| `/api/v1/users/me`                           | GET    | Профиль текущего пользователя и базовая статистика. |
| `/api/v1/users/me`                           | PATCH  | Обновление профиля (например, отображаемого имени). |
| `/api/v1/users/me`                           | DELETE | Удаление аккаунта и всех связанных ресурсов. |
| `/api/v1/files`                              | GET    | Список файлов пользователя с метаданными последней версии. |
| `/api/v1/files`                              | POST   | Создание файла и первой версии, возвращает URL загрузки. |
| `/api/v1/files/{file_id}`                    | GET    | Получение метаданных файла, включая последнюю версию. |
| `/api/v1/files/{file_id}`                    | PATCH  | Обновление метаданных файла (например, переименование). |
| `/api/v1/files/{file_id}`                    | DELETE | Удаление файла, всех версий, превью и публичных ссылок. |
| `/api/v1/files/{file_id}/versions`           | GET    | Список версий файла. |
| `/api/v1/files/{file_id}/versions`           | POST   | Создание новой версии, возвращает URL загрузки. |
| `/api/v1/files/{file_id}/versions/{num}/content` | GET | Получение подписанного URL для скачивания конкретной версии. |
| `/api/v1/files/{file_id}/versions/{num}/restore` | POST | Пометить указанную версию как актуальную. |
| `/api/v1/files/{file_id}/public-links`       | GET    | Список активных публичных ссылок для файла. |
| `/api/v1/files/{file_id}/public-links`       | POST   | Создание новой публичной ссылки с заданным TTL. |
| `/api/v1/files/{file_id}/public-links/{link_id}` | DELETE | Отзыв конкретной публичной ссылки. |

Точные схемы запросов и ответов (DTO, формат ошибок и т. д.) описаны в Swagger‑спеке в файлах `./docs/swagger.yaml` и `./docs/swagger.json`.  

---

### Наблюдаемость (метрики и трассировка)

В систему встроена базовая наблюдаемость через эндпоинт метрик и трассировку OpenTelemetry, настраиваемую в API‑сервере.  

- API отдаёт метрики по пути `/api/v1/metrics`, откуда их может забирать Prometheus или совместимые системы.  
- Воркер метрик потребляет события и агрегирует счётчики/гистограммы по запросам, задачам и доменным операциям.  
- OpenTelemetry инициализируется в `cmd/api/main.go` с помощью stdout‑экспортера и TracerProvider, а middleware оборачивает жизненный цикл HTTP‑запроса.  
- При необходимости трассы можно направить в Jaeger, Tempo или другой backend, заменив экспортёр.  

Этого достаточно для базового мониторинга задержек, нагрузки и ошибок без изменений в бизнес‑логике.  

---

### Локальная разработка

Для локального запуска нужны экземпляр Postgres и, опционально, MinIO и очередь (Kafka‑подобная), которые можно поднять через Docker Compose.  

Типовой сценарий разработки:  
1. Настроить конфиги `configs/config.base.yaml` и `configs/config.dev.yaml`, а также `.env` для секретов.  
2. Запустить зависимости (Postgres, MinIO, очередь) локально или через Docker.  
3. Накатить миграции из каталога `migrations/` выбранным инструментом миграций.  
4. Запустить API‑сервер командой `go run ./cmd/api`.  
5. При необходимости запустить `go run ./cmd/preview-worker` и `go run ./cmd/link-expirer` для фоновой обработки.  
6. Открыть `/swagger/index.html`, чтобы интерактивно исследовать и тестировать API.  

Тесты запускаются командой `go test ./...`, включая интеграционные тесты, которые взаимодействуют с Postgres, MinIO и мок‑очередью.  

---

### Возможные улучшения

Несмотря на уже чёткое разделение домена, инфраструктуры и исполняемых компонентов, у проекта есть очевидные направления развития.  

- Заменить in‑memory‑очереди на полноценный Kafka‑кластер в непроизводственных окружениях.  
- Добавить антивирусную проверку, классификацию контента и webhooks как дополнительные асинхронные задачи.  
- Вынести раздачу файлов и превью за CDN для улучшения глобальной производительности.  
- Улучшить поиск за счёт полнотекстового индексирования и тегов для больших объёмов данных.  
- Усилить безопасность: 2FA, более строгие политики токенов, подтверждение новых устройств.  
- Интегрировать трассировку и метрики с полноценным стеком наблюдаемости (Prometheus, Loki, Tempo/Jaeger).  

Текущая гексагональная архитектура и разделение API, воркеров и инфраструктуры позволяют относительно просто эволюционировать MVP в более распределённую или микросервисную систему при росте нагрузки.  
